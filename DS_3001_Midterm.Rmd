---
title: "Flow Package Overview"
author: Hallie Khuong, Tiffanie Luong, and Allison Feeney
output:
  html_document:
    toc: yes
    theme: united
    toc_float: yes
  flexdashboard::flex_dashboard: default
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(remotes)
#remotes::install_github("moodymudskipper/flow")
library(flexdashboard)
library(flow)
```

## Overview

The R package, flow, was created to help visualize what is going on in a script, function or expression. It creates a flow diagram, displaying each step of your function. This can help with debugging a complicated script or just understanding the logic of an algorithm. This package was created by Antoine Fabri (moodymudskipper on Github) and can be installed through github. He has also created other packages and is highly active on stackoverflow. Flow is still in its first version (0.0.1). 

### Package Imports

Flow is built on the nomnoml package and plantuml package. Nomnoml and plantuml are both UML diagram drawing packages.

Other imported packages: 

utf8       
cli         
vctrs       
pillar      
lifecycle   
tibble     
R.utils     
R.oo        
R.methodsS3 
ps          
processx    
callr      
xfun        
R.cache     
webshot     
styler      

## Usage
The main purpose of this package is to be used during debugging so we can better understand the logic behind built-in functions and the arguments it takes/how these arguments are used. Flow can also be used for functions that we create ourselves in order to ensure our functions are working the way that we want them to. For example, in our presentation, we wrote the function *test_function* which can be used as an argument within any of the flow methods. By doing so, we'd be able to see what our function does, and make any changes if we notice that our function isn't doing what we thought it would do. 

## Methods and Examples 

### Test function
For this presentation, we made our own function called *test_function* which returns the number of even numbers from 1 to a given number, n. We'll be using this function in the following examples to see how the flow functions works.

```{r}
test_function <- function(n){
  counter = 0
  for (i in 1:n){ #goes through numbers 1-n
    if( i %% 2 == 0){ #checks if the number is even
      counter = counter + 1  #increments the counter every time we get an even number
    }
  }
  return(counter) #returns the counter
}
```

### flow_view
The *flow_view* method can be used on a function, a quoted expression, or the path of an R script in order to visualize it. In this case, we ran flow_view on our function *test_function* to see the logic behind it. 
```{r}
flow_view(test_function)
```

### flow_run
The *flow_run* function allows you to visualize what path is being taken when a certain function is being **called**. This is different from flow_view in that it also gives you the output of the function. In this case, we tried running our function *test_function* on the number 5 with which the function accurately returns the number 2. This is because the only even numbers between 1 and 5 are 2 and 4. 

```{r, include = TRUE}
flow_run(test_function(5))
```
![](flow_run_test_function.png)

A better function we can use in order to show the functionality of this method would be this *is_even* function that we wrote because all it does is check whether or not an input is even. 
```{r, include = TRUE}
is_even <- function(n){
    if( n %% 2 == 0){ #checks if the number is even
      return (TRUE)
    }
    else{
      return (FALSE)
    }
}

flow_run(is_even(5))
```
![](flow_run_is_even.png)

From this flow diagram, we can see that with the input 5, the function goes down the return(FALSE) branch since 5 %% 2 does *not* equal 0. Consequently, it doesn't go down the return(TRUE), making this path dotted, as opposed to the solid arrow shown from if(n%%2 ==0) to return(FALSE).

### flow_data
The *flow_data* function shows the edge and node data that's generated by *flow_view*. In other words, it shows the types of methods that are used within the function, as well as how the function traverses down the flow chart created by the *flow_view* function.
```{r}
flow_data(test_function)
```

## Advantages and Disadvantages

### Advantages
- Helps with debugging
- Enables visualization when it comes to the logic flow of functions
- Can export the flow charts using a variety of different image file types (i.e. html, png, jpeg, pdf, etc.)

### Disadvantages
- Can't modify the aesthetics like you can in ggplot (colors, shapes, sizing, etc.)
- Gets complicated with some of the built in R functions since there's a lot of coding behind it (i.e. lm function)
```{r}
flow_view(lm)
```

